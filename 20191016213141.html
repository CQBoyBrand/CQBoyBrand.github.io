<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">
  <meta name="google-adsense-account" content="ca-pub-3799223021946643">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"brandhuang.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="《Javascript高级程序设计(第三版 )》这本书从刚毕业就在手上，到这篇文章之前，始终在前几章徘徊。现在抽空把看过的重要章节记录下，方便快速复习巩固">
<meta property="og:type" content="article">
<meta property="og:title" content="2019读书计划(4)——《Javascript高级程序设计(第三版 )》">
<meta property="og:url" content="http://brandhuang.com/20191016213141.html">
<meta property="og:site_name" content="重庆崽儿Brand博客">
<meta property="og:description" content="《Javascript高级程序设计(第三版 )》这本书从刚毕业就在手上，到这篇文章之前，始终在前几章徘徊。现在抽空把看过的重要章节记录下，方便快速复习巩固">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://static.brandhuang.com/admin-157063261192114.png">
<meta property="article:published_time" content="2019-10-16T13:31:41.000Z">
<meta property="article:modified_time" content="2024-03-04T03:53:13.384Z">
<meta property="article:author" content="重庆崽儿Brand">
<meta property="article:tag" content="重庆崽儿brand,vue,React,nuxt,blog,首页,JavaScript,js,css,html,web前端,前端开发,个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://static.brandhuang.com/admin-157063261192114.png">


<link rel="canonical" href="http://brandhuang.com/20191016213141.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://brandhuang.com/20191016213141.html","path":"20191016213141.html","title":"2019读书计划(4)——《Javascript高级程序设计(第三版 )》"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>2019读书计划(4)——《Javascript高级程序设计(第三版 )》 | 重庆崽儿Brand博客</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">重庆崽儿Brand博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC1%E7%AB%A0-Javascript%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">第1章 Javascript简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Javascript%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.1.</span> <span class="nav-text">1.2 Javascript实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0-%E5%9C%A8HTML%E4%B8%AD%E4%BD%BF%E7%94%A8Javascript"><span class="nav-number">2.</span> <span class="nav-text">第2章 在HTML中使用Javascript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 &lt;script&gt;元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%85%83%E7%B4%A0"><span class="nav-number">2.2.</span> <span class="nav-text">2.4 &lt;noscript&gt;元素</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.</span> <span class="nav-text">第3章 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E8%AF%AD%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.4 严格模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%8F%98%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">3.3 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">3.4 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-typeof%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%88%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.4.1 typeof操作符（不是函数）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-Number%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.4.5 Number类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-7-Object%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.4.7 Object类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.</span> <span class="nav-text">3.5 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.5.1 一元操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">1.递增和递减操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%80%E5%85%83%E5%8A%A0%E5%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">2.一元加减操作符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.5.2 位操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%8C%89%E4%BD%8D%E9%9D%9E%EF%BC%88NOT%EF%BC%89"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">1.按位非（NOT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8C%89%E4%BD%8D%E4%B8%8E%EF%BC%88AND%EF%BC%89"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">2.按位与（AND）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%8C%89%E4%BD%8D%E6%88%96%EF%BC%88OR%EF%BC%89"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">3.按位或（OR）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%EF%BC%88XOR%EF%BC%89"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">4.按位异或（XOR）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%B7%A6%E7%A7%BB"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">5.左移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%8F%B3%E7%A7%BB"><span class="nav-number">3.4.2.6.</span> <span class="nav-text">6.有符号的右移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8F%B3%E7%A7%BB"><span class="nav-number">3.4.2.7.</span> <span class="nav-text">7.无符号右移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.5.3 布尔操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%80%BB%E8%BE%91%E9%9D%9E"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">1. 逻辑非</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-10-%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">3.4.4.</span> <span class="nav-text">3.5.10 逗号操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-5-for-in%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.4.5.</span> <span class="nav-text">3.6.5 for-in语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-6-label%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.4.6.</span> <span class="nav-text">3.6.6 label语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-8-with%E8%AF%AD%E5%8F%A5"><span class="nav-number">3.4.7.</span> <span class="nav-text">3.6.8 with语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E5%87%BD%E6%95%B0"><span class="nav-number">3.5.</span> <span class="nav-text">3.7 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E7%AB%A0-%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">第4章 变量、作用域和内存问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 基本类型和引用类型的值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-%E5%A4%8D%E5%88%B6%E5%8F%98%E9%87%8F%E5%80%BC"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.2 复制变量值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-4-%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.4 检测类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 执行环境和作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E5%BB%B6%E9%95%BF%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 延长作用域链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%88%E5%B8%B8%E7%94%A8%E7%9A%84%EF%BC%89"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 标记清除（常用的）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 引用计数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 性能问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4 管理内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">第5章 引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Object%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 Object类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Array%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 Array类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 检测数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-%E6%A0%88%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.3 栈方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E9%98%9F%E5%88%97%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.4 队列方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-%E9%87%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.4.</span> <span class="nav-text">5.2.5 重排序方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-6-%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.5.</span> <span class="nav-text">5.2.6 操作方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-8-%E8%BF%AD%E4%BB%A3%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.6.</span> <span class="nav-text">5.2.8 迭代方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-9-%E5%BD%92%E5%B9%B6%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.7.</span> <span class="nav-text">5.2.9 归并方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-RegExp%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.3.</span> <span class="nav-text">5.4 RegExp类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.5.2 函数声明与函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-4-%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.5.4 函数内部属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-5-%E5%87%BD%E6%95%B0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.5.5 函数属性和方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.</span> <span class="nav-text">5.6 基本包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-1-Boolean%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.6.1 Boolean类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-2-Number%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.6.2 Number类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-3-String%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.4.3.</span> <span class="nav-text">5.6.3 String类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text">第6章 面向对象的程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.0.1.</span> <span class="nav-text">6.1.1 属性类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.1.</span> <span class="nav-text">6.2 创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.2.1 工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.2.2 构造函数模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.3.</span> <span class="nav-text">6.2.3 原型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.4.</span> <span class="nav-text">6.2.4 组合使用构造函数模式和原型模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-6-%E5%AF%84%E7%94%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.5.</span> <span class="nav-text">6.2.6 寄生构造函数模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-7-%E7%A8%B3%E5%A6%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.6.</span> <span class="nav-text">6.2.7 稳妥构造函数模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E7%BB%A7%E6%89%BF"><span class="nav-number">6.2.</span> <span class="nav-text">6.3 继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">第7章 函数表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E9%80%92%E5%BD%92"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 递归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E9%97%AD%E5%8C%85"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E6%A8%A1%E4%BB%BF%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 模仿块级作用域</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="重庆崽儿Brand"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">重庆崽儿Brand</p>
  <div class="site-description" itemprop="description">重庆崽儿brand的个人博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/CQBoyBrand" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CQBoyBrand" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:brandhuang@qq.com" title="E-Mail → mailto:brandhuang@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://brandhuang.com/20191016213141.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="重庆崽儿Brand">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="重庆崽儿Brand博客">
      <meta itemprop="description" content="重庆崽儿brand的个人博客">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="2019读书计划(4)——《Javascript高级程序设计(第三版 )》 | 重庆崽儿Brand博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2019读书计划(4)——《Javascript高级程序设计(第三版 )》
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-10-16 21:31:41" itemprop="dateCreated datePublished" datetime="2019-10-16T21:31:41+08:00">2019-10-16</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>《Javascript高级程序设计(第三版 )》这本书从刚毕业就在手上，到这篇文章之前，始终在前几章徘徊。现在抽空把看过的重要章节记录下，方便快速复习巩固</p>
<span id="more"></span>

<h1 id="第1章-Javascript简介"><a href="#第1章-Javascript简介" class="headerlink" title="第1章 Javascript简介"></a>第1章 Javascript简介</h1><h2 id="1-2-Javascript实现"><a href="#1-2-Javascript实现" class="headerlink" title="1.2 Javascript实现"></a>1.2 Javascript实现</h2><ul>
<li>一个完整的Javascript实现由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）和浏览器对象模型（BOM）。</li>
<li>常见的 Web 浏览器知识 ECMAScript 实现的宿主环境之一，其他环境包括 Node、Adobe Flash</li>
<li>DOM：是针对 XML 经过扩展用于 HTML 的API（提供访问和操作网页内容的方法和接口 ；DOM级别：DOM1、DOM2、DOM3）</li>
<li>BOM：控制浏览器显示的页面以外部分（提供与浏览器交互的方法和接口）</li>
</ul>
<h1 id="第2章-在HTML中使用Javascript"><a href="#第2章-在HTML中使用Javascript" class="headerlink" title="第2章 在HTML中使用Javascript"></a>第2章 在HTML中使用Javascript</h1><h2 id="2-1-元素"><a href="#2-1-元素" class="headerlink" title="2.1 &lt;script&gt;元素"></a>2.1 <code>&lt;script&gt;</code>元素</h2><ul>
<li>async：可选。表示&#x3D;&#x3D;不阻塞页面，下载并且执行脚本&#x3D;&#x3D;。不能保证执行的顺序。只对外部脚本文件有效。</li>
<li>defer：可选。表示&#x3D;&#x3D;立即下载脚本，脚本可延迟到文档被全部解析和显示后再执行&#x3D;&#x3D;。规范要求，按照脚本加载顺序执行（现实当中不一定）。只对外部脚本文件有效。</li>
<li><code>script</code> 脚本中不要嵌入出现”</script>“ 字符串，会被错误识别为结束标签。正确写法是：”&lt;/script&gt;”。</li>
</ul>
<p><img src="http://static.brandhuang.com/admin-157063261192114.png" alt="image"></p>
<h2 id="2-4-元素"><a href="#2-4-元素" class="headerlink" title="2.4 &lt;noscript&gt;元素"></a>2.4 <code>&lt;noscript&gt;</code>元素</h2><p>浏览器不支持脚本或者脚本被禁用，会显示<code>&lt;noscript&gt;</code>中的内容。</p>
<h1 id="第3章-基本概念"><a href="#第3章-基本概念" class="headerlink" title="第3章 基本概念"></a>第3章 基本概念</h1><h2 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h2><h3 id="3-1-4-严格模式"><a href="#3-1-4-严格模式" class="headerlink" title="3.1.4 严格模式"></a>3.1.4 严格模式</h3><p>ECMAScriipt 5 引入严格模式，在脚本或者函数顶部添加:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h2><ul>
<li>严格模式下，给未经声明的变量赋值，会抛出「ReferenceError」错误</li>
<li>var声明变量存在变量提升</li>
</ul>
<h2 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h2><p>5种简单数据类型（也称基本数据类型、原始数据类型）：Undefined、Null、Boolean、Number和String。</p>
<p>一种复杂数据类型：Object</p>
<p>Undefined只有一个值，即Undefined。var声明变量但未初始化时，变量的值就是Undefined</p>
<p>null只有一个值，即null，null值表示一个空对象指针</p>
<h3 id="3-4-1-typeof操作符（不是函数）"><a href="#3-4-1-typeof操作符（不是函数）" class="headerlink" title="3.4.1 typeof操作符（不是函数）"></a>3.4.1 typeof操作符（不是函数）</h3><p>检测给定变量的数据类型，返回值有：</p>
<ul>
<li>undefined——变量值未定义</li>
<li>boolean——变量值是布尔值</li>
<li>string——变量值是字符串</li>
<li>number——变量值是数值</li>
<li>object——变量值是对象或者null</li>
<li>function——变量值是函数</li>
</ul>
<h3 id="3-4-5-Number类型"><a href="#3-4-5-Number类型" class="headerlink" title="3.4.5 Number类型"></a>3.4.5 Number类型</h3><p><strong>NaN</strong>：</p>
<ul>
<li>任何涉及NaN的操作都会返回NaN</li>
<li>NaN与任何值都不相等，包括NaN本身</li>
</ul>
<p><strong>isNaN(params)函数</strong>：任何不能被转换成数值的值都会返回true</p>
<p><strong>数值转换</strong>：</p>
<ul>
<li>parseInt()应该在第二个参数指明进制。</li>
<li>parseFloat()只解析十进制值</li>
</ul>
<h3 id="3-4-7-Object类型"><a href="#3-4-7-Object类型" class="headerlink" title="3.4.7 Object类型"></a>3.4.7 Object类型</h3><p>Object 的每个实例都具有下列属性和方法：</p>
<ul>
<li>constructor()——保存着用于创建当前对象的函数</li>
<li>hasOwnProperty()——检查给定的属性在当前对象实例中(而不是在实例 的原型中)是否存在,参数为字符串</li>
<li>isPrototypeOf()——检查传入的对象是否是传入对象的原型,即obj1.isPrototypeOf(obj2): obj1 是不是在 obj2 的原型链上</li>
<li>propertyIsEnumerable(name)——检测name是否能够使用 for-in 语句来枚举</li>
<li>toLocaleString()——返回对象的字符串表示，该字符串与执行环境的地区对应</li>
<li>toString()——返回对象的字符串表示</li>
<li>valueOf()——返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。</li>
</ul>
<h2 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h2><h3 id="3-5-1-一元操作符"><a href="#3-5-1-一元操作符" class="headerlink" title="3.5.1 一元操作符"></a>3.5.1 一元操作符</h3><h4 id="1-递增和递减操作符"><a href="#1-递增和递减操作符" class="headerlink" title="1.递增和递减操作符"></a>1.递增和递减操作符</h4><ul>
<li><p>执行前置递增（递减）操作时，变量的值先改变再求值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">AgeNext</span> = --age + <span class="number">2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age)  <span class="comment">// 28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">AgeNext</span>)  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行后置递增（递减）操作时，变量先求值在执行后置操作</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> nnuum2 = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> num3 = num1-- + nuum2   <span class="comment">// 22</span></span><br><span class="line"><span class="keyword">var</span> num4 = num1 + nuum2  <span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<h4 id="2-一元加减操作符"><a href="#2-一元加减操作符" class="headerlink" title="2.一元加减操作符"></a>2.一元加减操作符</h4><ul>
<li>对非数值类型会执行类型转换</li>
</ul>
<h3 id="3-5-2-位操作符"><a href="#3-5-2-位操作符" class="headerlink" title="3.5.2 位操作符"></a>3.5.2 位操作符</h3><blockquote>
<p>ECMAScript中的所有数字都以EEE-754 64 位格式存储。但操作符不直接操作64位的值，而是先把64位转换成32位的整数，然后执行操作，最后将结果转换回64位</p>
</blockquote>
<blockquote>
<p>负数使用二进制补码存储，计算补码分三步：1、求这个数绝对值的二进制码；2、求二进制反码（即将 0换成1，将1换成 0）；3、得到的二进制反码加1.</p>
</blockquote>
<h4 id="1-按位非（NOT）"><a href="#1-按位非（NOT）" class="headerlink" title="1.按位非（NOT）"></a>1.按位非（NOT）</h4><p><code>~</code>: 返回数值的反码（本质：操作数的负值减1）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="number">25</span>; <span class="comment">// 二进制 00000011001</span></span><br><span class="line"><span class="keyword">var</span> num2 = ~num1 <span class="comment">//   11111100110</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num2) <span class="comment">// -26</span></span><br></pre></td></tr></table></figure>
<h4 id="2-按位与（AND）"><a href="#2-按位与（AND）" class="headerlink" title="2.按位与（AND）"></a>2.按位与（AND）</h4><p><code>&amp;</code>:按位与就是将两个数值的每一位对齐，两个数值的对应位&#x3D;&#x3D;都为1&#x3D;&#x3D;时才返回1，任何一位是0，都返回0；</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var result = 25 &amp; 4 // 输出 1</span><br><span class="line">25 = 0000 0000 0000 0000 0000 0000 0001 1001</span><br><span class="line"> 3 = 0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line"> ----------------------------------------------</span><br><span class="line">AND= 0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">只有最后一位同时都是1，所以输出 1</span><br></pre></td></tr></table></figure>
<h4 id="3-按位或（OR）"><a href="#3-按位或（OR）" class="headerlink" title="3.按位或（OR）"></a>3.按位或（OR）</h4><p><code>|</code>:两个数值的对应位&#x3D;&#x3D;都为0时&#x3D;&#x3D;才返回0，任何一位是1，都返回1；</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var result = 25 &amp; 4 // 输出 27</span><br><span class="line">25 = 0000 0000 0000 0000 0000 0000 0001 1001</span><br><span class="line"> 3 = 0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line"> ----------------------------------------------</span><br><span class="line">OR = 0000 0000 0000 0000 0000 0000 0001 1011</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="4-按位异或（XOR）"><a href="#4-按位异或（XOR）" class="headerlink" title="4.按位异或（XOR）"></a>4.按位异或（XOR）</h4><p><code>^</code>：对应位上&#x3D;&#x3D;只有一个 1&#x3D;&#x3D; 时才返回 1，如果对 应的两位都是 1 或都是 0，则返回 0</p>
<figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var result = 25 ^ 4 // 输出 26</span><br><span class="line">25 = 0000 0000 0000 0000 0000 0000 0001 1001</span><br><span class="line"> 3 = 0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line"> ----------------------------------------------</span><br><span class="line">XOR= 0000 0000 0000 0000 0000 0000 0001 1010</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-左移"><a href="#5-左移" class="headerlink" title="5.左移"></a>5.左移</h4><p><code>&lt;&lt;</code>：将数值的所有位向左移动指定的位数。左移操作会&#x3D;&#x3D;以 0 来填充这些空位&#x3D;&#x3D;.左移不会影响操作数的符号位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var oldValue = 2; // 等于二进制的10</span><br><span class="line">var newValue = oldValue &lt;&lt; 5; // 等于二进制的1000000，十进制的64</span><br></pre></td></tr></table></figure>
<h4 id="6-有符号的右移"><a href="#6-有符号的右移" class="headerlink" title="6.有符号的右移"></a>6.有符号的右移</h4><p><code>&gt;&gt;</code>：数值向右移动，&#x3D;&#x3D;用符号位的值来填充所有空位&#x3D;&#x3D;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = <span class="number">64</span>; <span class="comment">// 等于二进制的1000000</span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt; <span class="number">5</span>; <span class="comment">// 等于二进制的10 ，即十进制的2</span></span><br></pre></td></tr></table></figure>
<h4 id="7-无符号右移"><a href="#7-无符号右移" class="headerlink" title="7.无符号右移"></a>7.无符号右移</h4><p><code>&gt;&gt;&gt;</code>：将数值的所有 32 位都向右移动，对正 数来说，无符号右移的结果与有符号右移相同。对负数来说,首先，无符号右移是以 0 来填充空位.其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oldValue = <span class="number">64</span>;</span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等于二进制的1000000</span></span><br><span class="line"><span class="comment">// 等于二进制的10 ，即十进制的2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldValue = -<span class="number">64</span>; <span class="comment">// 等于二进制的11111111111111111111111111000000 </span></span><br><span class="line"><span class="keyword">var</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 等于十进制的 134217726</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-3-布尔操作符"><a href="#3-5-3-布尔操作符" class="headerlink" title="3.5.3 布尔操作符"></a>3.5.3 布尔操作符</h3><h4 id="1-逻辑非"><a href="#1-逻辑非" class="headerlink" title="1. 逻辑非"></a>1. 逻辑非</h4><p><code>!</code>：将它的操作数转换为一个布尔值，然后再 对其求反</p>
<p><code>!!</code> &#x3D;&#x3D;&gt;得到该值的真正布尔值</p>
<h3 id="3-5-10-逗号操作符"><a href="#3-5-10-逗号操作符" class="headerlink" title="3.5.10 逗号操作符"></a>3.5.10 逗号操作符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 声明多个变量:</span></span><br><span class="line"><span class="keyword">var</span> num1=<span class="number">1</span>, num2=<span class="number">2</span>, num3=<span class="number">3</span>;</span><br><span class="line"><span class="comment">// 在用于赋值时，逗号 操作符总会返回表达式中的最后一项，</span></span><br><span class="line"><span class="keyword">var</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">// num的值为0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-6-5-for-in语句"><a href="#3-6-5-for-in语句" class="headerlink" title="3.6.5 for-in语句"></a>3.6.5 for-in语句</h3><p>精准的迭代语句，可以用来枚举对象的属性,由于ECMAScript中对象的属性没有顺序,所以输出的属性名的顺序是不可预测的</p>
<p>使用 for-in 循环之前，先检测&#x3D;&#x3D;确认该对象的值不是 null 或 undefined&#x3D;&#x3D;，ECMAScript 5 之前会报错。</p>
<h3 id="3-6-6-label语句"><a href="#3-6-6-label语句" class="headerlink" title="3.6.6 label语句"></a>3.6.6 label语句</h3><blockquote>
<p>使用 label 语句可以在代码中添加标签，以便将来使用</p>
</blockquote>
<p>break 和 continue 语句与 label 语句联合使用，多用在循环嵌套的情况下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 与break配合使用</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">num++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(num);    <span class="comment">//95 </span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="attr">outermost</span>:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> outermost;</span><br><span class="line">        &#125;</span><br><span class="line">num++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(num);    <span class="comment">//55 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  与continue配合使用</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">num++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(num);    <span class="comment">//99</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="attr">outermost</span>:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123; <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span> outermost;</span><br><span class="line">&#125;</span><br><span class="line">num++; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(num);    <span class="comment">//95</span></span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;注意：&#x3D;&#x3D; 虽然联用 break、continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试 带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。</p>
<h3 id="3-6-8-with语句"><a href="#3-6-8-with语句" class="headerlink" title="3.6.8 with语句"></a>3.6.8 with语句</h3><p>with 语句的作用是将代码的作用域设置到一个特定的对象中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qs = location.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> hostName = location.<span class="property">hostname</span>;</span><br><span class="line">    <span class="keyword">var</span> url = location.<span class="property">href</span>;</span><br><span class="line"><span class="comment">// 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示:</span></span><br><span class="line"><span class="title function_">with</span>(<span class="params">location</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = search.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> hostName = hostname;</span><br><span class="line">    <span class="keyword">var</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此<br>在开发大型应用程序时，不建议使用 with 语句</strong></p>
<h2 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h2><p>return 语句可以不带任何返回值，默认返回值是undefined</p>
<p>arguments对象是类数组对象，通过length获取传入参数的个数，用中括号语法访问它的每一个参数。严格模式下，重写 arguments 的值会导致语法错误(代码将不会执行)。</p>
<h1 id="第4章-变量、作用域和内存问题"><a href="#第4章-变量、作用域和内存问题" class="headerlink" title="第4章 变量、作用域和内存问题"></a>第4章 变量、作用域和内存问题</h1><h2 id="4-1-基本类型和引用类型的值"><a href="#4-1-基本类型和引用类型的值" class="headerlink" title="4.1 基本类型和引用类型的值"></a>4.1 基本类型和引用类型的值</h2><p>5 种 基本数据类型:Undefined、Null、Boolean、Number 和 String，&#x3D;&#x3D;按值访问&#x3D;&#x3D;</p>
<p>引用类型的值是按引用访问的</p>
<h3 id="4-1-2-复制变量值"><a href="#4-1-2-复制变量值" class="headerlink" title="4.1.2 复制变量值"></a>4.1.2 复制变量值</h3><p>如果从一个变量向另一个变量&#x3D;&#x3D;复制基本类型的值&#x3D;&#x3D;，会在变量对象上&#x3D;&#x3D;创建一个新值&#x3D;&#x3D;，然后把该值复制 到为新变量分配的位置上</p>
<p>当从一个变量向另一个变量&#x3D;&#x3D;复制引用类型的值&#x3D;&#x3D;时，值的副本实际上是一个&#x3D;&#x3D;指针&#x3D;&#x3D;，指向存储在堆中的一 个对象，复制操作结束后，两个变量实际上将&#x3D;&#x3D;引用同一个对象&#x3D;&#x3D;，&#x3D;&#x3D;改变其中一个变量，就会影响另 一个变量&#x3D;&#x3D;</p>
<p>**&#x3D;&#x3D;ECMAScript 中所有函数的参数都是按值传递的&#x3D;&#x3D;**：在向参数&#x3D;&#x3D;传递基本类型&#x3D;&#x3D;的值时，被&#x3D;&#x3D;传递的值&#x3D;&#x3D;会被复制给一个局部变量。在向参数&#x3D;&#x3D;传递引用类型的值&#x3D;&#x3D;时，会把 这个值&#x3D;&#x3D;在内存中的地址复制给一个局部变量&#x3D;&#x3D;，因此这个局部变量的变化会反映在函数的外部</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123; </span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>; </span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>);    <span class="comment">//&quot;Nicholas&quot;,如果是按引用传递，则应该是输出&quot;Greg&quot;</span></span><br></pre></td></tr></table></figure>
<p>局部对象会在函数执行完毕后立即被销毁</p>
<h3 id="4-1-4-检测类型"><a href="#4-1-4-检测类型" class="headerlink" title="4.1.4 检测类型"></a>4.1.4 检测类型</h3><p>基本数据类型：typeof；引用类型检测：instanceof</p>
<h2 id="4-2-执行环境和作用域"><a href="#4-2-执行环境和作用域" class="headerlink" title="4.2 执行环境和作用域"></a>4.2 执行环境和作用域</h2><p>作用域链的用途：保证对执行环境有权访问的所有变量和函数的有序访问</p>
<h3 id="4-2-1-延长作用域链"><a href="#4-2-1-延长作用域链" class="headerlink" title="4.2.1 延长作用域链"></a>4.2.1 延长作用域链</h3><p>在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。</p>
<ul>
<li>try-catch 语句的 catch 块;</li>
<li>with 语句</li>
</ul>
<p>对 with 语句来说，会将指定的对象添加到<br>作用域链中。对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<h2 id="4-3-垃圾收集"><a href="#4-3-垃圾收集" class="headerlink" title="4.3 垃圾收集"></a>4.3 垃圾收集</h2><h3 id="4-3-1-标记清除（常用的）"><a href="#4-3-1-标记清除（常用的）" class="headerlink" title="4.3.1 标记清除（常用的）"></a>4.3.1 标记清除（常用的）</h3><blockquote>
<p>所有变量打标记；去掉环境中变量的标记，以及被环境中变量引用变量的标记；之后，清除还有标记的变量</p>
</blockquote>
<p>当变量进入环境(例如，在函<br>数中声明一个变量)时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其 标记为“离开环境”。</p>
<h3 id="4-3-2-引用计数"><a href="#4-3-2-引用计数" class="headerlink" title="4.3.2 引用计数"></a>4.3.2 引用计数</h3><blockquote>
<p>跟踪每个变量引用次数，被引用的变量就加 1；如果此变量又取了另一个变量，减 1。</p>
</blockquote>
<h3 id="4-3-3-性能问题"><a href="#4-3-3-性能问题" class="headerlink" title="4.3.3 性能问题"></a>4.3.3 性能问题</h3><p>IE 的垃圾收集器是根据内存分配量运行的,达到临界值就会运行.如果一个脚本中包含那么多变 量，那么该脚本很可能会在其生命周期中一直保有那么多的变量.造成垃圾收集器频繁地运行</p>
<p>IE7后，临界值是动态修正，如果 垃圾收集例程回收的内存分配量低于 15%，临界值就会加倍；如果 例程回收了 85%的内存分配量，则将各种临界值重置回默认值。</p>
<h3 id="4-3-4-管理内存"><a href="#4-3-4-管理内存" class="headerlink" title="4.3.4 管理内存"></a>4.3.4 管理内存</h3><p>解除引用(dereferencing)：一旦数据不再有用，通过将其值设置为 null 来释放其引用。</p>
<p>解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离 执行环境，以便垃圾收集器下次运行时将其回收。</p>
<h1 id="第5章-引用类型"><a href="#第5章-引用类型" class="headerlink" title="第5章 引用类型"></a>第5章 引用类型</h1><h2 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a>5.1 Object类型</h2><p>创建object实例：</p>
<ul>
<li>new 操作符后跟 Object 构造函数：var person &#x3D; new Object();</li>
<li>使用对象字面量表示法: var person &#x3D; {};</li>
</ul>
<h2 id="5-2-Array类型"><a href="#5-2-Array类型" class="headerlink" title="5.2 Array类型"></a>5.2 Array类型</h2><p>创建数组：</p>
<ul>
<li>使用 Array 构造函数：var colors &#x3D; new Array();</li>
<li>使用<code>[]</code></li>
</ul>
<p>数组的 length 属性可读写。数组不存在的位置的值为<code>undefined</code></p>
<h3 id="5-2-1-检测数组"><a href="#5-2-1-检测数组" class="headerlink" title="5.2.1 检测数组"></a>5.2.1 检测数组</h3><p>ES5使用<code>Array.isArray()</code>。instanceof不适用于网页包含多个框架，两个以上不同的全局执行环境，存在两个以上不同版本的 Array 构造函数，从一个向另一个传入数组构造函数，严格意义上并不相等</p>
<h3 id="5-2-3-栈方法"><a href="#5-2-3-栈方法" class="headerlink" title="5.2.3 栈方法"></a>5.2.3 栈方法</h3><blockquote>
<p>栈是一种 LIFO(Last-In-First-Out， 后进先出)的数据结构,插入和移除只发生在栈顶。</p>
</blockquote>
<ul>
<li>push()方法接收任意数量的参数,添加到数组末尾,&#x3D;&#x3D;并返回修改后数组的长度&#x3D;&#x3D;</li>
<li>pop()方法从数组末尾移除最后一项，&#x3D;&#x3D;返回移除的项&#x3D;&#x3D;</li>
</ul>
<h3 id="5-2-4-队列方法"><a href="#5-2-4-队列方法" class="headerlink" title="5.2.4 队列方法"></a>5.2.4 队列方法</h3><blockquote>
<p>队列是一种 FIFO(First-In-First-Out， 先进先出)的数据结构，发生在列表的前端和末端</p>
</blockquote>
<ul>
<li>shift()方法&#x3D;&#x3D;移除&#x3D;&#x3D;数组中的第一个项并&#x3D;&#x3D;返回该项&#x3D;&#x3D;</li>
<li>unshift()方法在数组前端&#x3D;&#x3D;添加&#x3D;&#x3D;任意个项并&#x3D;&#x3D;返回新数组的长度&#x3D;&#x3D;</li>
</ul>
<h3 id="5-2-5-重排序方法"><a href="#5-2-5-重排序方法" class="headerlink" title="5.2.5 重排序方法"></a>5.2.5 重排序方法</h3><ul>
<li>reverse()方法会反转数组项的顺序</li>
<li>sort()不传参数时按照字符编码的顺序进行排序，传入一个函数时，函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等 则返回 0，如果第一个参数应该位于第二个之后则返回一个正数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr元素为数值类型</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">30</span>,<span class="number">10</span>,<span class="number">26</span>]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareUp</span>(<span class="params">value1, value2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> value1 - value2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareDown</span>(<span class="params">value1, value2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br><span class="line">arr.<span class="title function_">sort</span>(compareUp) <span class="comment">// 升序排列（数字从小到大）</span></span><br><span class="line">arr.<span class="title function_">sort</span>(compareDown) <span class="comment">// 降序排列（数字从大到小）</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-6-操作方法"><a href="#5-2-6-操作方法" class="headerlink" title="5.2.6 操作方法"></a>5.2.6 操作方法</h3><blockquote>
<p>前两个方法不影响原数组，第三个方法会影响原数组。</p>
</blockquote>
<ul>
<li>concat()会&#x3D;&#x3D;创建一个新的数组&#x3D;&#x3D;，参数会被自动展开</li>
<li>slice()会&#x3D;&#x3D;创建一个新数组&#x3D;&#x3D;，可进行删除（2个参数），插入（3个参数，第二个为0），替换（3个参数）操作</li>
<li>splice()方法返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何 项，则返回一个空数组）</li>
</ul>
<h3 id="5-2-8-迭代方法"><a href="#5-2-8-迭代方法" class="headerlink" title="5.2.8 迭代方法"></a>5.2.8 迭代方法</h3><blockquote>
<p>以下方法均不会修改数组中的包含的值</p>
</blockquote>
<ul>
<li>every():&#x3D;&#x3D;每一项&#x3D;&#x3D;都返回true，则返回true。</li>
<li>some():&#x3D;&#x3D;任一项&#x3D;&#x3D;都返回true，则返回true</li>
<li>filter()：返回执行结果为true的项组成的数组</li>
<li>forEach()：没有返回值</li>
<li>map()：返回执行后的结果组成的&#x3D;&#x3D;新数组&#x3D;&#x3D;</li>
</ul>
<h3 id="5-2-9-归并方法"><a href="#5-2-9-归并方法" class="headerlink" title="5.2.9 归并方法"></a>5.2.9 归并方法</h3><blockquote>
<p>使用 reduce()还是 reduceRight()，主要取决于要从哪头开始遍历数组。除此之外，它们完全 相同。</p>
</blockquote>
<ul>
<li>reduce():数组从第一个开始，逐个向后遍历</li>
<li>reduceRight()： 数组从最后一个开始，向前遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">//15</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">var</span> sum = values.<span class="title function_">reduceRight</span>(<span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> prev + cur;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">alert</span>(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<h2 id="5-4-RegExp类型"><a href="#5-4-RegExp类型" class="headerlink" title="5.4 RegExp类型"></a>5.4 RegExp类型</h2><p>RegExp 构造 函数的模式参数是字符串，某些情况下要对字符进行双重转义，例如<code>\n</code>(字符<code>\</code>在字符串中通常被转义为<code>\\</code>）</p>
<p>RegExp 的每个实例都具有下列属性：</p>
<ul>
<li>global:布尔值，表示是否设置了 g 标志</li>
<li>ignoreCase:布尔值，表示是否设置了 i 标志。</li>
<li>lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。</li>
<li>multiline:布尔值，表示是否设置了 m 标志。</li>
<li>source:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回</li>
</ul>
<h3 id="5-5-2-函数声明与函数表达式"><a href="#5-5-2-函数声明与函数表达式" class="headerlink" title="5.5.2 函数声明与函数表达式"></a>5.5.2 函数声明与函数表达式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span> (num1, num2) &#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>解析器在向执行环 境中加载数据时：</p>
<ul>
<li>解析器会率先读取函数声明。</li>
<li>函数表达式，则必须等到解析器执行到它所在的代码行，才会真 正被解释执行</li>
</ul>
<p>对代码求值时,声明函数会被js引擎提升到顶部</p>
<h3 id="5-5-4-函数内部属性"><a href="#5-5-4-函数内部属性" class="headerlink" title="5.5.4 函数内部属性"></a>5.5.4 函数内部属性</h3><blockquote>
<p>在函数内部，有两个特殊的对象:<code>arguments</code> 和 <code>this</code></p>
</blockquote>
<p><code>arguments</code>的主要用途是保存函数参数，该对象有个<code>callee</code>的属性，指向拥有<code>arguments</code>对象的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阶乘</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num * <span class="title function_">factorial</span>(num-<span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化:解除函数的执行与函数名 factorial的耦合</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num-<span class="number">1</span>)</span><br><span class="line">&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> trueFactorial = factorial;</span><br><span class="line">    factorial = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="title function_">trueFactorial</span>(<span class="number">5</span>));     <span class="comment">//120</span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="title function_">factorial</span>(<span class="number">5</span>));         <span class="comment">//0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>this</code> 引用的是函数据以执行的环境对象</p>
<blockquote>
<p>函数名仅仅是一个包含指针的变量</p>
</blockquote>
<p>ECMAScript 5 也规范化了另一个函数对象的属性<code>caller</code>,这个属性中保存着&#x3D;&#x3D;调用当前函数的函数的引用&#x3D;&#x3D;， 如果是在全局作用域中调用当前函数，它的值为<code> null</code></p>
<p>严格模式下:访问 <code>arguments.callee</code> 和 <code>arguments.caller</code> 会导致错误。</p>
<p>严格模式下： 不能为函数的 caller 属性赋值，否则会导致错误。</p>
<p>非严格模式下： <code>arguments.caller</code> 的值是<code>undefined</code></p>
<h3 id="5-5-5-函数属性和方法"><a href="#5-5-5-函数属性和方法" class="headerlink" title="5.5.5 函数属性和方法"></a>5.5.5 函数属性和方法</h3><blockquote>
<p>每个函数都包含两个 属性:<code>length</code> 和 <code>prototype</code></p>
</blockquote>
<p><code>prototype</code>是不可枚举的,不能用 for-in 枚举</p>
<p>每个函数都包含两个非继承而来的方法:<code>apply()</code>和 <code>call()</code></p>
<h2 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a>5.6 基本包装类型</h2><p>ECMAScript提供3个特殊的引用类型：Boolean、Number 和 String</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// s1是基本类型，不是对象，但是调用了substring方法，是因为js引擎自动进行了一系列处理</span></span><br><span class="line"><span class="comment">// (1) 创建 String 类型的一个实例;</span></span><br><span class="line"><span class="comment">// (2) 在实例上调用指定的方法;</span></span><br><span class="line"><span class="comment">// (3) 销毁这个实例</span></span><br></pre></td></tr></table></figure>
<p>引用类型与基本包装类型的主要区别就是对象的生存期</p>
<p>自动创建的基本包装类型的对象，只存在于代码执行的瞬间，然后立即被销毁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">    s1.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="title function_">alert</span>(s1.<span class="property">color</span>);   <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>注意！！</strong>：使用<code>new</code>调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">&quot;25&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> number = <span class="title class_">Number</span>(value); <span class="comment">//转型函数 alert(typeof number); //&quot;number&quot;</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Number</span>(value); <span class="comment">//构造函数 alert(typeof obj); //&quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-6-1-Boolean类型"><a href="#5-6-1-Boolean类型" class="headerlink" title="5.6.1 Boolean类型"></a>5.6.1 Boolean类型</h3><p>基本类型与引用类型的布尔值有两个区别：</p>
<ul>
<li>typeof 操作符对基本类型返回”boolean”， 而对引用类型返回”object”</li>
<li>由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof 操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> falseValue = <span class="literal">false</span>;</span><br><span class="line"><span class="title function_">alert</span>(typeoffalseObject); </span><br><span class="line">object <span class="title function_">alert</span>(<span class="keyword">typeof</span> falseValue); <span class="comment">//boolean</span></span><br><span class="line"><span class="title function_">alert</span>(falseObject <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"><span class="title function_">alert</span>(falseValue <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>&#x3D;&#x3D;建议永远不要使用Boolean对象&#x3D;&#x3D;</p>
<h3 id="5-6-2-Number类型"><a href="#5-6-2-Number类型" class="headerlink" title="5.6.2 Number类型"></a>5.6.2 Number类型</h3><ul>
<li>toFixed(小数位数)，能够自动舍入的特性，可以表示带有 0 到 20 个小数位的数值（IE8 及之前版本不能正确 舍入范围在{(-0.94,-0.5],[0.5,0.94)}之间的值）</li>
<li>toExponential(小数位数),转化为科学计数法，返回字符串。</li>
</ul>
<h3 id="5-6-3-String类型"><a href="#5-6-3-String类型" class="headerlink" title="5.6.3 String类型"></a>5.6.3 String类型</h3><ul>
<li>String.fromCharCode(…charcodes): 将字符编码转化为字符串。</li>
<li>String.charCodeAt(index): 将 index 的字符转化为字符编码。</li>
</ul>
<p>string.match(pattern) 返回一个数组</p>
<h1 id="第6章-面向对象的程序设计"><a href="#第6章-面向对象的程序设计" class="headerlink" title="第6章 面向对象的程序设计"></a>第6章 面向对象的程序设计</h1><blockquote>
<p>ECMA-262 把对象定义为:“无序属性的集合，其属性可以包含基本值、对象或者函数。”</p>
</blockquote>
<h3 id="6-1-1-属性类型"><a href="#6-1-1-属性类型" class="headerlink" title="6.1.1 属性类型"></a>6.1.1 属性类型</h3><blockquote>
<p>通过Object.defineProperty(属性所在的对象，属性的名字，一个描述符对象)方法,修改属性默认的特性(在IE8以上的版本中使用)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>数据属性<blockquote>
<p>可以多次调用 <code>Object.defineProperty()</code> 修改下列属性，除了将 configurable 设置为 false。</p>
</blockquote>
</li>
</ol>
<ul>
<li><code>Configurable</code>:表示能否通过 delete 删除属性,默认值为 true</li>
<li><code>Enumerable</code>: 表示能否通过 for-in 循环返回属性,默认值为 true</li>
<li><code>Writable</code>: 表示能否修改属性的值,默认值为 true</li>
<li><code>Value</code>: 包含这个属性的数据值。读取属性值的时候，从这个位置读;写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。</li>
</ul>
<ol start="2">
<li>访问器属性</li>
</ol>
<blockquote>
<p>访问器属性不能直接定义，必须使用 Object.defineProperty()来定义,只设置<code>Get(Set)</code>时，意味着属性是不能写（意味着属性是不能读）</p>
</blockquote>
<ul>
<li><code>Configurable</code>:表示能否通过 delete 删除属性,默认值为 true</li>
<li><code>Enumerable</code>: 表示能否通过 for-in 循环返回属性,默认值为 true</li>
<li><code>Get</code>: 在读取属性时调用的函数。默认值为 undefined</li>
<li><code>Set</code>: 在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
<h2 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h2><blockquote>
<p>使用Object 构造函数或对象字面量创建对象，缺点：使用同<br>一个接口创建很多对象，会产生大量的重复代码</p>
</blockquote>
<h3 id="6-2-1-工厂模式"><a href="#6-2-1-工厂模式" class="headerlink" title="6.2.1 工厂模式"></a>6.2.1 工厂模式</h3><blockquote>
<p>解决了创建 多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        o.<span class="property">name</span> = name;</span><br><span class="line">        o.<span class="property">age</span> = age;</span><br><span class="line">        o.<span class="property">job</span> = job;</span><br><span class="line">        o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">return</span> o; &#125;</span><br><span class="line">    <span class="keyword">var</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">//（从这里体现没有解决对象识别问题）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person1 <span class="keyword">instanceof</span> createPerson) <span class="comment">// false</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-构造函数模式"><a href="#6-2-2-构造函数模式" class="headerlink" title="6.2.2 构造函数模式"></a>6.2.2 构造函数模式</h3><p>与工厂函数相比的区别：</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了 this 对象</li>
<li>没有 return 语句。</li>
</ul>
<p>创建 Person 的新实例，必须使用 new 操作符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;; &#125;</span><br><span class="line">    <span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">alert</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>);  <span class="comment">//true</span></span><br><span class="line">    <span class="title function_">alert</span>(person1 <span class="keyword">instanceof</span> <span class="title class_">Person</span>);  <span class="comment">//true</span></span><br><span class="line">    <span class="title function_">alert</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Object</span>);  <span class="comment">//true</span></span><br><span class="line">    <span class="title function_">alert</span>(person2 <span class="keyword">instanceof</span> <span class="title class_">Person</span>);  <span class="comment">//true</span></span><br><span class="line">    <span class="comment">// 构造函数的实例可以被标识为一种特定的类型</span></span><br></pre></td></tr></table></figure>
<p>构造函数的主要问题：每个方法都要在每个实例上重新创建一遍。</p>
<p>person1 和 person2 都有一个名为 sayName()的方法，但那 两个方法不是同一个 Function 的实例</p>
<p>为了解决上述问题，将上述代码修改如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = sayName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该方法出现了新的问题：<code>sayName()</code>是定义在全局作用域中的函数， 在全局作用域中定义的函数实际上只能被某个对象调用。于是出现了原型模式</p>
<h3 id="6-2-3-原型模式"><a href="#6-2-3-原型模式" class="headerlink" title="6.2.3 原型模式"></a>6.2.3 原型模式</h3><blockquote>
<p>每个函数都有一个prototype(原型)属性,它是一个指针，指向一个对象,包含可以由特定类型的&#x3D;&#x3D;所有实例&#x3D;&#x3D;共享的属性和方法</p>
</blockquote>
<ol>
<li>理解原型对象</li>
</ol>
<p>创建一个新函数时，会默认创建一个<code>prototype</code>属性，指向函数的原型对象，默认所有原型对象会有一个<code>constructor</code>属性，<code>constructor</code>属性包含一个指向 <code>prototype</code> 属性所在函数的指针.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> 指向 <span class="title class_">Person</span></span><br></pre></td></tr></table></figure>

<p>可以通过对象实例访问保存在原型中的值，但不能通过对象实例重写原型中的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>; <span class="number">12</span> <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(person1.<span class="property">name</span>); <span class="comment">//&quot;Greg&quot;——来自实例 alert(person2.name); //&quot;Nicholas&quot;——来自原型</span></span><br></pre></td></tr></table></figure>

<p>用<code>person1.hasOwnProperty(属性名)</code>方法可以检测一个属性是存在于实例中（返回true）还是原型中（返回false）。</p>
<ol start="2">
<li>原型与 in 操作符<blockquote>
<p>两种方式使用 in 操作符:单独使用和在 for-in 循环中使用</p>
</blockquote>
</li>
</ol>
<p>单独使用时，in 操作符会在通 过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person1);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>同时使用 hasOwnProperty()方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于 原型中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hasPrototypeProperty</span>(<span class="params">object, name</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> !object.<span class="title function_">hasOwnProperty</span>(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-in 循环,返回的是&#x3D;&#x3D;所有能够通过对象访问的、可枚举的(enumerated)属性&#x3D;&#x3D;，其中 既包括存在于&#x3D;&#x3D;实例中&#x3D;&#x3D;的属性，也包括存在于&#x3D;&#x3D;原型中&#x3D;&#x3D;的属性，屏蔽了原型中不可枚举属性(即将 [[Enumerable]]标记为 false 的属性)的实例属性也会在 for-in 循环中返回.</p>
<p>使用 ECMAScript 5 的 <code>Object.keys()</code>方法，取得对象上&#x3D;&#x3D;所有可枚举&#x3D;&#x3D;的实例属性,返回一个包含所有可枚举属性的字符串&#x3D;&#x3D;数组&#x3D;&#x3D;</p>
<ol start="4">
<li>原型的动态性<blockquote>
<p>实例与原型 之间的连接只不过是一个指针，而非一个副本,在实例中没有找到的属性会继续去原型中搜索</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.<span class="title function_">sayHi</span>(); <span class="comment">//&quot;hi&quot;(没有问题!)</span></span><br></pre></td></tr></table></figure>

<p>如果创建实例后再重写原型，会有不一样的情况</p>
<blockquote>
<p><strong>注意</strong>：实例中的指针仅指向原型，而不是指向构造函数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="comment">// 重写原型，此时就切断了构造函数与最初原型的联系</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Person</span>,</span><br><span class="line">    name : <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    age : <span class="number">29</span>,</span><br><span class="line">    job : <span class="string">&quot;Software Engineer&quot;</span>,</span><br><span class="line">    sayName : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">friend.<span class="title function_">sayName</span>();   <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-组合使用构造函数模式和原型模式"><a href="#6-2-4-组合使用构造函数模式和原型模式" class="headerlink" title="6.2.4 组合使用构造函数模式和原型模式"></a>6.2.4 组合使用构造函数模式和原型模式</h3><p><strong>构造函数：</strong> 用于定义实例属性。</p>
<p><strong>原型模式：</strong> 用于定义共享属性和方法</p>
<h3 id="6-2-6-寄生构造函数模式"><a href="#6-2-6-寄生构造函数模式" class="headerlink" title="6.2.6 寄生构造函数模式"></a>6.2.6 寄生构造函数模式</h3><blockquote>
<p>除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实 是一模一样的</p>
</blockquote>
<p><strong>说明：</strong> 返回的对象与构造函数或者与构造函数的原型属 性之间没有关系，不能依赖 instanceof 操作符来确定对象类型</p>
<h3 id="6-2-7-稳妥构造函数模式"><a href="#6-2-7-稳妥构造函数模式" class="headerlink" title="6.2.7 稳妥构造函数模式"></a>6.2.7 稳妥构造函数模式</h3><blockquote>
<p>稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。</p>
</blockquote>
<p>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同:</p>
<ul>
<li>一是新创建对象的 实例方法不引用 this;</li>
<li>二是不使用 new 操作符调用构造函数。</li>
</ul>
<blockquote>
<p>在JavaScript构造函数中：如果return值类型，那么对构造函数没有影响，实例化对象返回空对象；如果return引用类型（数组，函数，对象），那么实例化对象就会返回该引用类型；</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Super</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span>=a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Super1</span>(<span class="params">a</span>)&#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">a</span>=a;</span><br><span class="line">     <span class="keyword">return</span> &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Super1</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Super</span>(<span class="number">1</span>));      <span class="comment">//返回Super&#123;a:1&#125;,有原型方法sayHello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Super1</span>(<span class="number">2</span>));     <span class="comment">//返回Object&#123;a:2&#125;,没有原型方法sayHello</span></span><br></pre></td></tr></table></figure>
<h2 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h2><p>接口继承：继承方法签名</p>
<p>实现继承：继承实际的方法</p>
<p>ECMAScript 只支持实现继承，主要是依靠原型链 来实现的</p>
<h1 id="第7章-函数表达式"><a href="#第7章-函数表达式" class="headerlink" title="第7章 函数表达式"></a>第7章 函数表达式</h1><blockquote>
<p>定义函数的 方式有两种:一种是函数声明，另一种就是函数表达式</p>
</blockquote>
<p>函数声明，它的一个重要特征就是&#x3D;&#x3D;函数声明提升&#x3D;&#x3D;</p>
<h2 id="7-1-递归"><a href="#7-1-递归" class="headerlink" title="7.1 递归"></a>7.1 递归</h2><p>经典递归</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="number">6</span></span><br><span class="line">         <span class="keyword">return</span> num * <span class="title function_">factorial</span>(num-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会出现一个问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherFactorial = factorial; </span><br><span class="line">factorial = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">alert</span>(<span class="title function_">anotherFactorial</span>(<span class="number">4</span>)); <span class="comment">//出错!</span></span><br></pre></td></tr></table></figure>
<p>将以上代码再次修改：<br>arguments.callee 是一个指向正在执行的函数的指针</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num * <span class="variable language_">arguments</span>.<span class="title function_">callee</span>(num-<span class="number">1</span>);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>但在严格模式下，不能通过脚本访问 arguments.callee</p>
<p>于是再次修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">num</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num * <span class="title function_">f</span>(num-<span class="number">1</span>);</span><br><span class="line">&#125; &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="7-2-闭包"><a href="#7-2-闭包" class="headerlink" title="7.2 闭包"></a>7.2 闭包</h2><blockquote>
<p>闭包是指：有权访问另一个函数作用域中的变量的函数。作用域得到了延长。</p>
</blockquote>
<h2 id="7-3-模仿块级作用域"><a href="#7-3-模仿块级作用域" class="headerlink" title="7.3 模仿块级作用域"></a>7.3 模仿块级作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>整理完毕！！！</strong></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/20190925130203.html" rel="prev" title="巩固下js中Call、Apply和Bind的区别">
                  <i class="fa fa-angle-left"></i> 巩固下js中Call、Apply和Bind的区别
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/20191130204311.html" rel="next" title="JavaScript版数据结构与算法——基础篇（一）">
                  JavaScript版数据结构与算法——基础篇（一） <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">渝ICP备17014610号 </a>
      <img src="/images/beian.png" alt=""><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=50011702500392" rel="noopener" target="_blank">渝公网安备50011702500392号 </a>
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">重庆崽儿Brand</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
